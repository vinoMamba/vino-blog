# 前端知识点总结

## HTML 部分

#### 1. 你是如何理解 HTML 语义化的

纵观整个前端的发展史来看，最先开始还没出现前端工程师这个岗位的时候,那时候前端页面还是由后端自己来写 HTML，那时候还是使用 table 标签来写页面，这种情况下还容易出现 table 套 table 的情况。

后来前端出现的初期，那时候称为美工阶段。因为那时候主要采用的是**DIV+CSS**来布局，虽然比远古时期的 table 布局要更加灵活，但是有个最大的缺陷是他不够语义化。整个页面全都是 DIV，浏览器以及其他同事都不能够很好的理解网页。
甚至 SEO(搜索引擎优化)也不友好。

再到现在的阶段，前端这个行业更加成熟。开始使用专业的标签来写网页，用 p 标签来表示段落，用 h1 标签来表示标题，用 article 标签来表示文章等等。这么做的好处就是整个网页更加语义化。更容易让浏览器读懂网页内容，SEO
更加友好，在网页加载不出 CSS 的时候页面也能够呈现出良好的结构。最后也更加方便同事维护。

> 引申问题
>
> 1. 什么是 SEO，如何优化 SEO

#### 2. meta viewport 是做什么的，怎么写

> [head GitHub](https://github.com/joshbuchea/HEAD)

```html

<meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
/>
```

上述 GitHub 地址有，想要的结果。另外也可以直接打开国内比较大的互联网公司的网站，查看他们是怎么写的。

meta 提供有关页面的元信息，比如针对搜索引擎的描述和关键词。viewport 是 meta 标签 name 属性的一个可选值。移动设备上的 viewport
标签是设备屏幕上用来显示网页的那部分区域，再具体一点就是浏览器来显示页面的区域。width 设置宽度等于设备的宽度，initial-scale=1.0 不允许缩放。

#### 3. 你用过那些 HTML5 的标签

1. header,main,footer,article
2. canvas,video

> 引申问题
>
> 1. canvas 是怎么用的
>
> 2. video 是怎么用的

#### 4. H5 是什么

广义的解释

1. 就是指的是 HTML5，即第五代超文本标记语言

2. 其实很早之前 HTM5 就已经出了，但是到最近突然受到很多的关注，这其实跟手机等移动设备的快速发展离不开关系。以前的网页在手机的浏览器上根本无法正常的查看，随着上网方式的变更也就推动了技术的更新，HTML5
   最重要的特性之一就是增强了对移动设备的支持，兼容性得到了提升。

狭义的解释

1. 互动形式的多媒体广告页面。

2. 投入成本低，获取的收益高。如今在互联网社交媒介如微博，微信，钉钉等，在这些媒介间，h5 的移动端网页是最高效的转播方式。

3. 另外诸如钉钉的微应用，微信端网页，小程序等发，采用 H5 开发是最高效的方式。

## CSS 部分

#### 1. 盒模型

分别 content-box 和 border-box。每个盒子有四个部分组成，分别是：content，padding，border，margin

content-box 是指 width 由内容决定，不包括 padding、border

boder-box(IE 盒子) 是指 width 的值包括 content、padding、border 的值

一般都是使用 border-box，因为这个更好用，便于计算

#### 2. 如何实现水平垂直居中

##### 定宽高

1. 绝对定位 + 负 margin 值

```css
.box {
    width: 200px;
    height: 200px;
    border: 1px solid red;
    position: relative;
}

.cildren-box {
    width: 100px;
    height: 100px;
    position: absolute;
    top: 50%;
    left: 50%;
    margin-left: -50px;
    margin-top: -50px;
    background-color: pink;
}
```

2. 绝对定位 + transform

```css
.box {
    width: 200px;
    height: 200px;
    border: 1px solid red;
    position: relative;
}

.cildren-box {
    width: 100px;
    height: 100px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: pink;
}
```

3. 绝对定位 + left/right/top/bottom + margin

```css
.box {
    width: 200px;
    height: 200px;
    border: 1px solid red;
    position: relative;
}

.children-box {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
    width: 100px;
    height: 100px;
    background-color: pink;
}
```

4. flex

```css
.box {
    width: 200px;
    height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.children-box {
    width: 100px;
    height: 100px;
    background-color: pink;
}
```

5. grid

```css
.box {
    width: 200px;
    height: 200px;
    border: 1px solid red;
    display: grid;
}

.children-box {
    width: 100px;
    height: 100px;
    margin: auto;
    background-color: pink;
}
```

6. table-cell + vertical-align + inline-block/margin:auto

```css
.box {
    width: 200px;
    height: 200px;
    border: 1px solid red;
    display: table-cell;
    text-align: center;
    vertical-align: middle;
}

.children-box {
    width: 100px;
    height: 100px;
    background-color: pink;
    margin: auto; /*display: inline-block;*/
}
```

##### 不定宽高

1. 绝对定位 + transform

```css
.box {
    width: 200px;
    height: 200px;
    border: 1px solid red;
    position: relative;
}

.children-box {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
```

2. table-cell

```css
.box {
    width: 200px;
    height: 200px;
    border: 1px solid red;
    display: table-cell;
    text-align: center;
    vertical-align: middle;
}

.children-box {
    background-color: pink;
    display: inline-block;
}
```

3. flex

```css
.box {
    width: 200px;
    height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.children-box {
    background-color: pink;
}
```

4. flex 变异布局

```css
.box {
    width: 200px;
    height: 200px;
    display: flex;
}

.children-box {
    background-color: pink;
    margin: auto;
}
```

5. flex + grid

```css
.box {
    width: 200px;
    height: 200px;
    border: 1px solid red;
    display: grid;
}

.children-box {
    background-color: pink;
    align-self: center;
    justify-content: center;
}
```

6. flex + margin

```css
.box {
    width: 200px;
    height: 200px;
    border: 1px solid red;
    display: grid;
}

.children-box {
    background-color: pink;
    margin: auto;
}
```

> 拔高
>
> 为什么水平居中比垂直居中容易

#### 3. flex 布局怎么用的

以下代码，实现两个 div 靠右，一个 div 靠左显示

```html

<div class="container">
    <div class="box1"></div>
    <div class="box2"></div>
    <div class="box3"></div>
</div>
```

```css
.container {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.container > div {
    width: 48px;
    height: 36px;
    background-color: pink;
}

.box2 {
    margin-left: auto;
}
```

#### 4. BFC 是什么

BFC 的全称是**块级格式化上下文**

1. overflow:hidden

2. display:inline-block

3. position: absolute

4. position: fixed

5. display: table-cell

6. display: flex

解决的问题：

1. float 布局高度塌陷的问题

2. margin 垂直边距重叠问题

3. 两栏布局内容覆盖问题

#### 5. CSS 选择器优先级

1. 越具体的优先级越高
2. 同样优先级写在后面的会覆盖前面的
3. !important 优先级最高

错误的可以得分的答案

1. 内联样式表权值最高 1000
2. ID 选择器 100
3. class 10
4. 标签选择器 1

#### 6. 清除浮动

```css
.clearfix:after {
    content: "";
    display: block;
    clear: both;
}

.clearfix {
    zoom: 1; /*兼容IE*/
}
```

## Promise,async/await,微任务/宏任务,EventLoop 专题

#### 1. Promise

1. promise.all 的用法,在接收的第一个promise如果失败了，那么后面的就会中断执行

```javascript
const task1 = () => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject("第一扇门关了");
        }, 3000);
    });
};
const task2 = () => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject("第二扇门关了");
        }, 5000);
    });
};
const task3 = () => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("第三扇门开了");
        }, 7000);
    });
};
const x = (promise) =>
    promise().then(
        () => ({status: "ok"}),
        () => ({status: "not ok"})
    );
Promise.all([x(task1), x(task2), x(task3)]).then((result) => {
    console.log(result);
});
```

2. Promise.race 只要有一个成功（失败）

3. 使用场景 搜索的时候，第一个搜索结果由于网络原因或者其他原因没有出结果，用户等不及就搜了第二个关键字。

#### 2. async / await

```javascript
const fn = async () => {
    const temp = await makePromise()
    return temp + 1
}
```

> async/await 是 Promise的语法糖。await 必须是在 async 里面，所以如果需要设置setTimeout，那就没法使用
>
> 为什么一定要写async，如果用到了await不就代表已经是async函数了么？这个做的原因是为了兼容旧代码里面自己写的await()函数。async 是做标记用，为了区分旧代码

await 错误处理

```javascript
// 常见写法(很丑)
let response
try {
    response = await axios.get('/xxx')
} catch (e) {
    if (response.e) {
        console.log(e.response.states)
    }
    throw  e
}
// 正确写法
const response2 = await axios.get('/xxx').then(null, errorHandler)
console.log(response)
/*
* await 只关心成功，失败全部交给errorHandler来处理 
* */
```

await 有传染性，Promise同样有传染性，会导致同步的代码变成异步，所以将同步执行的代码应该写在await上面

```javascript
console.log(1)
await console.log(2)
console.log(3)  // 这里会变成异步的
```

#### 2. EventLoop

> 当JS执行一个异步任务的时候，其实JS什么也没做，JS只是发了个消息通知 C++,让C++来处理这个任务，然后JS又去做他后面的事情去了。C++在处理这个任务的时候遵循一定得规则来处理这个任务，然后在返回给JS

EventLoop 是 node.js的概念，他有以下6个阶段

1. timers

2. <p style="text-decoration:line-through">I/O cb (no care)</p>

3. <p style="text-decoration: line-through">idle prepore (no care)</p>

4. poll

5. check

6. <p style="text-decoration: line-through">close cb (no care)</p>

**timers**

## JavaScript

#### 1. ES6 语法，分别怎么用

1. let、const、 ... 操作符、箭头函数、解构赋值、模块的导入导出、Promise、Symbol 类型

#### 3. 手写防抖，节流

```javascript
//节流
function throttle(fn, delay) {
    let canUse = true
    return function () {
        if (canUse) {
            fn.apply(this, arguments)
            canUse = false
            setTimeout(() => canUse = true, delay)
        }
    }
}

//防抖
function debounce(fn, delay) {
    let timerId = null
    return function () {
        const context = this
        if (timerId) {
            window.clearTimeout(timerId)
        }
        timerId = setTimeout(() => {
            fn.apply(context, arguments)
            timerId = null
        }, delay)
    }
}
```

#### 4. 手写 Ajax

```javascript
const request = new XMLHttpRequest()
request.open('GET', '/xxx', true)
request.onreadystatechange = function () {
    if (request.readyState === 4 && request.status === 200) {
        console.log(request.response)
    }
}
request.send()
```

#### 5. this 的指向

#### 6. 闭包、立即执行函数

#### 7. JSONP , CORS , 什么是跨域

#### 8. 深拷贝

#### 9. 如何用正则实现 trim()

#### 10. 不用 class 如何实现继承，用 class 又如何实现

#### 11. 数组去重

#### 12. == 相关题目，直接反着答

> 从不用 == 都是使用 ===
