## 数据结构

### 1. 数据结构概述

1. 定义

> 如何吧现实中大量复杂的问题以**特定的数据类型**和**特定的存储结构**保存到内存中。以及在此基础上为实现某个功能而执行的相应操作，这个操作叫做算法

> 个体如何来存储，个体与个体之间的关系如何存储；数据结构 = 个体 + 个体的关系

2. 算法

> 在数据结构的基础上为实现某个功能而执行的相应操作，这些操作叫做算法

> 算法依附于一个数据结构

衡量算法的标准：

- 时间复杂度（大概需要执行的次数）
- 空间复杂度（执行过程中大概占用的最大内存）
- 难以程度
- 健壮性

3. 数据结构的地位

> 数据结构是计算机的最核心课程之一

### 2. 预备知识

> 伪算法 ==> 带有指针的语言实现

#### 1. 指针

> 学完了

```c
#include <stdio.h>

void showArray(int *p, int len) {
    for (int i = 0; i < len; ++i) {
        printf("%d\n", p[i]);
    }
}

int main() {
    int a[5] = {1, 2, 3, 4, 5};
    showArray(a, 5);
    return 0;
}
```

#### 2. 结构体

1. 为什么出现结构体

> 为了表示一些复杂的数据类型。而普通的基本类型无法满足要求

2. 结构体定义

> 用户根据实际需要自己定义的数据类型

3. 如何使用结构体

```c
#include <stdio.h>
#include <string.h>

struct Student {
    int sid;
    char name[200];
    int age;
};


void init_student(struct Student *pst) {
    pst->sid = 200;
    pst->age = 24;
    strcpy(pst->name, "useF");
}

void printf_student(struct Student *pst) {
    printf("%d %s %d\n", pst->sid, pst->name, pst->age);
}

int main(void) {
    struct Student std = {100, "vino", 24};
    std.sid = 98;
    strcpy(std.name, "mamba");
    printf("%d %s %d\n", std.sid, std.name, std.age);

    struct Student *pst;
    pst = &std;
    pst->sid = 99;

    struct Student st;
    init_student(&st);
    printf_student(&st);
    return 0;
}
```

> 动态输入数组

```c
#include <stdio.h>
#include <malloc.h>

int main(void) {
    int arr[5] = {4, 3, 6, 5, 2};
    int len;
    printf("input length\n");
    scanf("%d", &len);
    // *pArr 这里取得是数组第一个元素的地址
    int *pArr = (int *) malloc(sizeof(int) * len);
    for (int i = 0; i < len; i++)
        scanf("%d", &pArr[i]);
    for (int i = 0; i < len; i++)
        printf("%d\n", *(pArr + i));
    free(pArr);
    return 0;
}

```

#### 3. 动态内存的分配和释放

```c
#include <stdio.h>
#include <malloc.h>

struct Student {
    int sid;
    int age;
};

struct Student *CreateStudent(void) {
    struct Student *p = (struct Student *) malloc(sizeof(struct Student));
    p->sid = 100;
    p->age = 45;
    return p;
};

void ShowStudent(struct Student *pst) {
    printf("sid=%d;age=%d", pst->sid, pst->age);
};

int main() {
    struct Student *ps;
    ps = CreateStudent();
    ShowStudent(ps);

    return 0;
}
```

### 3. 模块一：线性结构

> 把所有的节点，用一根直线穿起来

#### 1. 连续存储-[数组]

> 元素的类型必须相同，大小必须相等

```c
#include <stdio.h>
#include <malloc.h>
#include <assert.h>
#include <stdbool.h>

struct Arr {
    int *pBase; // 数组第一个元素的地址
    int length; // 数组能容纳元素的最大个数
    int cnt;
};

//初始化数组
void init_arr(struct Arr *pArr, int length) {
    pArr->pBase = (int *) malloc(sizeof(int) * length);
    if (pArr->pBase == NULL) {
        printf("error");
        exit(-1);
    } else {
        pArr->length = length;
        pArr->cnt = 0;
        printf("%d - %d \n", pArr->length, pArr->cnt);
    }
}
//是否为空
bool is_empty(struct Arr *pArr) {
    return pArr->cnt == 0;
}

// 展示数组
void show_arr(struct Arr *pArr) {
    if (!is_empty(pArr)) {
        printf("[");
        for (int i = 0; i < pArr->cnt; i++) {
            printf("%d ", pArr->pBase[i]);
        }
        printf("]\n");
    } else {
        printf("array is empty!\n");
    }
}
// 是否已经满了
bool is_full(struct Arr *pArr) {
    return pArr->length == pArr->cnt;
}
// 添加元素
bool append_arr(struct Arr *pArr, int val) {
    if (is_full((struct Arr *) &pArr)) {
        return false;
    } else {
        pArr->pBase[pArr->cnt] = val;
        (pArr->cnt)++;
        return true;
    }
}
//插入元素
bool insert_arr(struct Arr *pArr, int index, int val) {
    if (index < 0 || index >= pArr->length) return false;
    if (is_full(pArr))return false;
    pArr->cnt++;
    for (int i = pArr->cnt; i > index; i--) {
        pArr->pBase[i] = pArr->pBase[i - 1];
    }
    pArr->pBase[index] = val;
    return true;
}
// 删除元素
bool delete_arr(struct Arr *pArr, int index, int *pVal) {
    if (is_empty(pArr)) return false;
    if (index < 0 || index >= pArr->cnt) return false;
    *pVal = pArr->pBase[index];
    for (int i = index; i < pArr->cnt; i++) {
        pArr->pBase[i] = pArr->pBase[i + 1];
    }
    pArr->cnt--;
    return true;
}

//倒置
void reverse_arr(struct Arr *pArr) {
    int i = 0;
    int j = pArr->cnt - 1;
    int temp;
    while (i < j) {
        temp = pArr->pBase[i];
        pArr->pBase[i] = pArr->pBase[j];
        pArr->pBase[j] = temp;
        i++;
        j--;
    }
}

int main() {
    struct Arr arr;
    init_arr(&arr, 5);
    append_arr(&arr, 1);
    append_arr(&arr, 2);
    append_arr(&arr, 3);
    append_arr(&arr, 4);
    append_arr(&arr, 4);
    show_arr(&arr);
    int val;
    delete_arr(&arr, 2, &val);
    show_arr(&arr);
    reverse_arr(&arr);
    show_arr(&arr);
    return 0;
}

```

#### 2. 离散存储-[链表]

> n 各节点离散分配，彼此通过指针相连，每个节点只有一个前驱结点和一个后续节点。首节点没有前驱结点，尾结点没有后续节点

- 首节点：第一个有效节点
- 尾节点：最后一个有效节点
- 头节点：没有存放有效数据，也没有存放链表的长度。头节点作用是为了方便对链表算法的操作
- 头指针：指向头节点的指针变量
- 尾指针：指向尾节点的指针变量

> 只需要得到头指针，就可以推导出链表的所有信息

**分类**

- 单链表
- 双链表
- 循环链表
- 非循环链表




#### 3. 线性结构的两种常见应用之一：栈

#### 4. 线性结构的两种常见应用之二：队列

#### 5. 专题：递归

### 4. 模块二：非线性结构

#### 1. 树

#### 2. 图

### 5. 模块三：查找和排序

#### 1. 折半查找

#### 2. 排序
