# 你不知道的JavaScript（上）- 函数作用域和块级作用域

## 1. 函数中的作用域

> 每声明一个函数都会为其自身创建一个作用域

```javascript
function foo(a) {
    var b = 2

    function bar() {

    }

    var c = 3
}
```

1. `foo`的作用域气泡中包含了`a`,`b`,`c`和`bar`
2. `bar`拥有自己的作用域气泡，全局作用域也拥有自己的作用域气泡，他只包含了一个标识符`foo`
3. `a`,`b`,`c`和`bar` 都属于 `foo` 的作用域气泡，这就意味着无法从外部对他们进行访问
4. 但是这些标识符在`foo`的内部是都可以被访问到的，同样在`bar`的作用域中也可以被访问（假设内部没有同名的标识符）

> 函数作用域的含义
>
>   1. 属于这个函数的全部变量都可以在整个函数的范围内使用以及复用
>   2. 这种设计是非常有用的，能充分利用JavaScript变量可以根据需要改变类型的“动态”特性

## 2. 隐藏内部实现

> 对函数的传统认知就是先声明一个函数，然后再往里面添加代码
>
> 反过来：**从所写的代码中挑选出任意的片段，然后利用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了**
>
>   1. 实际结果就是在这个代码段的周围创建了一个作用域气泡
>   2. 这段代码中的任何声明都将绑定在这个新创建的作用域中

### 为什么“隐藏”变量和函数是一个有用的技术

#### 1. 代码应该符合最小特权原则

> 在软件设计中，应该最小限度的暴露必要内容，而将其他内容都“隐藏”起来
>
> 这个原则可以延伸到**如何选择作用域来包含变量和函数**
> 如果所有的变量和函数都在全局作用域中，当然这样在所有内嵌的作用域中都可以访问到他们
> 但这样做就会破坏**最小特权原则**。某些变量或者函数本应该是私有的，正确的代码应该是可以阻止对这些变量或者函数的访问
>

#### 2.规避冲突

> “隐藏”作用域的的另一个好处是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字，但是可能功能不一样
>
>   1. 全局命名空间：命名冲突最典型的例子是在全局作用域中。在加载第三方库的时候，如果没有妥善的将私有变量或者函数“隐藏” 起来，就很容易引发冲突
>   2. 模块管理：模块管理则是利用作用域的规则强制所有的标识符都不能注入到共享作用域中，这样可以有效的避免冲突

## 3. 函数作用域

> 函数作用域能很好的解决一些问题，但也不是理想的。因为也会导致一些新的问题出现
>
>   1. 一个具名函数`foo()`，意味着`foo`这个名称本身“污染”所在作用域
>   2. 其次还必须显示的去调用`foo`才能运行其中的代码

### JavaScript的解决方案

```javascript
var a = 2;

(function foo() {
    var a = 3
    console.log(a)
})()

console.log(a)
```

> 函数声明和函数表达式
>
>   1. 区分函数表达式和函数声明最简单的方式是看`function`关键字是否是声明中的第一个词，如果是则是函数声明，否则函数表达式
>   2. 函数声明和函数表达式之间最重要的区别是**他们的名称标识符将会绑定在何处**
>
>比较前面两片代码，第一个片段中`foo`被绑定在所在的作用域中，可以直接通过`foo()`来调用；第二个片段`foo`
> 被绑定在函数表达式自身的函数中。这意味着`foo`只能在`(function foo(){..})`中的`..`代表的位置访问。
>

#### 1. 匿名和具名

```javascript
setTimeout(function () {
    console.log('我等一会执行')
}, 0)
```

> 这叫做**匿名函数表达式**。而函数声明是不可以省略函数名，在JavaScript中是非法的
>
> 这种方式有几个缺点：
>
>   1. 匿名函数在栈追踪的时候不会显示具体的函数名，导致调试很困难
>   2. 在递归中，函数引用自身将无法实现。另一个例子就是事件触发监听器的时候需要解绑自身
>   3. 匿名函数的可读性相对于具名函数较差
>
> 解决这些问题：给函数表达式命名是最佳实践

```javascript
setTimeout(function waitAMoment() {
    console.log('我等一会执行')
}, 0)
```

#### 2. 立即执行函数表达式

> 由于函数被包裹在一个`()`内，因此成为了一个表达式，在通过尾部增加另外一个`()`，就可以立即执行这个函数
> 专业术语叫做**IIFE**(Immediately Invoked Function Expression)
>
> IIFE最常见的用法是使用匿名函数表达式。当然具名函数表达式也具备同样的优势

##### IIFE进阶用法

```javascript
var a = 2;
(function IIEF(a) {
    console.log(a)
})(a)
```

## 4. 块作用域

```javascript
for (var i = 0; i < 10; i++) {
    console.log(i)
}
```

> 上述代码中，`i`变量是指在循环内部使用的变量。但事实是`i`已经污染到整个函数作用域。表面上看JavaScript并没有块级作用域的相关功能

### try...catch

```javascript
try {

} catch (error) {
    console.log(error);
}
console.log(error) //ReferenceError
```

### let

> let 关键字可以将变量绑定到所在的任意作用域中

```javascript
for (let i = 0; i < 10; i++) {
    console.log(i)
}
console.log(i) //ReferenceError
```

> `let`不仅将`i`绑定到了for循环里面，而且是将其绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值

```javascript
let j
for (j = 0; j < 10; j++) {
    let i = j
    console.log(i)
}
```

### const
> 用于创建块作用域变量，但是其值是固定的常量


















































