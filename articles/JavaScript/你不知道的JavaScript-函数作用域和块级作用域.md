# 你不知道的JavaScript（上）- 函数作用域和块级作用域

## 1. 函数中的作用域

> 每声明一个函数都会为其自身创建一个作用域

```javascript
function foo(a) {
    var b = 2

    function bar() {

    }

    var c = 3
}
```

1. `foo`的作用域气泡中包含了`a`,`b`,`c`和`bar`
2. `bar`拥有自己的作用域气泡，全局作用域也拥有自己的作用域气泡，他只包含了一个标识符`foo`
3. `a`,`b`,`c`和`bar` 都属于 `foo` 的作用域气泡，这就意味着无法从外部对他们进行访问
4. 但是这些标识符在`foo`的内部是都可以被访问到的，同样在`bar`的作用域中也可以被访问（假设内部没有同名的标识符）

> 函数作用域的含义
>
>   1. 属于这个函数的全部变量都可以在整个函数的范围内使用以及复用
>   2. 这种设计是非常有用的，能充分利用JavaScript变量可以根据需要改变类型的“动态”特性

## 2. 隐藏内部实现

> 对函数的传统认知就是先声明一个函数，然后再往里面添加代码
>
> 反过来：**从所写的代码中挑选出任意的片段，然后利用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了**
>
>   1. 实际结果就是在这个代码段的周围创建了一个作用域气泡
>   2. 这段代码中的任何声明都将绑定在这个新创建的作用域中

### 为什么“隐藏”变量和函数是一个有用的技术

#### 1. 代码应该符合最小特权原则

> 在软件设计中，应该最小限度的暴露必要内容，而将其他内容都“隐藏”起来
>
> 这个原则可以延伸到**如何选择作用域来包含变量和函数**
> 如果所有的变量和函数都在全局作用域中，当然这样在所有内嵌的作用域中都可以访问到他们
> 但这样做就会破坏**最小特权原则**。某些变量或者函数本应该是私有的，正确的代码应该是可以阻止对这些变量或者函数的访问
>

#### 2.规避冲突

> “隐藏”作用域的的另一个好处是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字，但是可能功能不一样
>
>   1. 全局命名空间：命名冲突最典型的例子是在全局作用域中。在加载第三方库的时候，如果没有妥善的将私有变量或者函数“隐藏” 起来，就很容易引发冲突
>   2. 模块管理：模块管理则是利用作用域的规则强制所有的标识符都不能注入到共享作用域中，这样可以有效的避免冲突

## 3. 函数作用域

> 函数作用域能很好的解决一些问题，但也不是理想的。因为也会导致一些新的问题出现
>
>   1. 一个具名函数`foo()`，意味着`foo`这个名称本身“污染”所在作用域
>   2. 其次还必须显示的去调用`foo`才能运行其中的代码

### JavaScript的解决方案

#### 1. 立即执行函数

```javascript
var a = 2;

(function foo() {
    var a = 3
    console.log(a)
})()

console.log(a)
```

#### 2. 匿名函数






















