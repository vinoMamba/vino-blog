# 你不知道的JavaScript（上）- 词法作用域

> 作用域有两种主要的工作模型
>
> 1. 词法作用域(大多数语言采用的工作模型)
> 2. 动态作用域(Bash脚本等)

## 1. 词法阶段

> 大部分标准语言编译器的第一个工作阶段：**词法化**，词法化的过程会对源代码的字符进行检查，如果是有状态的解析过程，还会赋予单词语义
>
> 简单来说：词法作用域就是定义词法阶段的作用域，是由你在写代码是将变量和块作用域写在哪里决定的

```javascript
function foo(a) {
    var b = a * 2

    function bar(c) {
        console.log(a, b, c)
    }

    bar(b * 3)
}

foo(2)
```

这个例子中有三个逐级嵌套的作用域

1. 全局作用域，其中只有一个标识符`foo`
2. 包含着`foo`创建的作用域，标识符：`a`,`bar`,`b`
3. 包含着`bar`创建的作用域，标识符：`c`

作用域查找是逐级查询的，从最内部作用域开始逐级向外执行，直到找到第一个匹配的标识符停止。在多层嵌套作用域中可以定义同名的标识符，这叫做“遮蔽效应”。


> 无论函数在哪里调用，也无论他如何被调用，他的词法作用域只由函数被声明时所处的位置决定

## 2. 欺骗词法

> 欺骗词法作用域会导致性能下降

### 1. eval

```javascript
function foo(str, a) {
    eval(str)
    console.log(a, b)
}

var b = 2
foo("var b = 3;", 1) //1  3
```

> `eval('var b = 3')` 会被当做本来就在那里的一段代码来处理，因此就会屏蔽掉外层定义的变量`b`
>
> JavaScript中还有其他的一些功能效果和`eval`相似，例如`setTimeout`的第一个参数可以是字符串，并
> 且可以被解释为一段代码执行。这些功能已过时且不提倡使用！

### 2. with(同样不推荐使用)

### 3. 性能

> 如果引擎在代码中发现了`eval`,`with`，他只能简单的假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段
> 明确知道`eval`会接收什么样的代码，这些代码会如何对作用域进行修改。如果代码中出现大量的`eval`,`with`,那么运行起来就
> 一定很慢，影响性能
















