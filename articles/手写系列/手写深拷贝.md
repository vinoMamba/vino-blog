## 手写深拷贝

#### 深拷贝的简单理解

`b`是`a`的一份拷贝，`b`中没有对`a`中对象的引用

#### 另一种理解

1. `b`是`a`的一份拷贝

2. 把 `b` 和 `a` 各画一张图，`a`与`b`没有连接

## 方式一: JSON序列化反序列化

```javascript
const a = {
    b: 1,
    c: [1, 2, 3],
    d: {age: 21, name: 'vino'}
}
const a2 = JSON.parse(JSON.stringify(a))
```

#### 缺点

1. 不支持拷贝**函数**、**undefined**、**Date(会转换成ISO8601时间字符串)**、**正则**等等JSON不支持的类型

2. 不支持环状的结构数据(`a.self = a`)

3. ....

## 方式二: 递归克隆

[递归克隆的方式实现深拷贝](https://github.com/vinoMamba/deep-clone)

#### 使用测试驱动开发的方式来编写深拷贝

下面只给出每一步的代码，测试用例请查看[源代码](https://github.com/vinoMamba/deep-clone)

1. 支持拷贝基本类型数据

```javascript
function deepClone(source) {
    return source
}
```

2. 支持复制普通对象

```javascript
function deepClone(source) {
    if (source instanceof Object) {
        const dist = new Object()
        for (let key in dist) {
            dist[key] = deepClone(source[key])
        }
        return dist
    }
    return source
}
```

3. 支持拷贝数组

```javascript
function deepClone(source) {
    if (source instanceof Array) {
        const dist = new Array()
        for (let key in dist) {
            dist[key] = deepClone(source[key])
        }
        return dist
    } else {
        const dist = new Object()
        for (let key in dist) {
            dist[key] = deepClone(source[key])
        }
        return dist
    }
    return source
}
```

4. 支持拷贝数组

```javascript
function deepClone(source) {
    if (source instanceof Array) {
        const dist = new Array()
        for (let key in dist) {
            dist[key] = deepClone(source[key])
        }
        return dist
    } else if (source instanceof Function) {
        const dist = function () {
            return source.apply(this, arguments)
        }

        for (let key in dist) {
            dist[key] = deepClone(source[key])
        }
        return dist
    } else {
        const dist = new Object()
        for (let key in dist) {
            dist[key] = deepClone(source[key])
        }
        return dist
    }
    return source
}
```












